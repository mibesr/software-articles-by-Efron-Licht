<!DOCTYPE html><html><head>
  <title>Golang Quirks &amp; Intermediate Tricks, Pt 1: Declarations, Control Flow, &amp; Typesystem</title>
  <meta name="GENERATOR" content="github.com/gomarkdown/markdown markdown processor for Go"/>
  <meta charset="utf-8"/>
  <link rel="stylesheet" type="text/css" href="/s.css"/>
  <link rel="icon" type="image/x-icon" href="/favicon.ico"/>
</head>
<body>

<h1>Golang Quirks &amp; Intermediate Tricks, Pt 1: Declarations, Control Flow, &amp; Typesystem</h1>

<h4>A programming article by Efron Licht</h4>

<h4>Feb 2023</h4>

<h2><a href="https://eblog.fly.dev">more articles</a></h2>

<ul>
<li>bytehacking <a href="./bytehacking.html">html</a> <a href="./bytehacking.md">markdown</a></li>
<li><a href="./faststack.html">tale of two stacks</a> <a href="./faststack.md">markdown</a></li>
<li><a href="./quirks.html">go quirks &amp; tricks, pt 1</a> <a href="./quirks.md">markdown</a></li>
<li><a href="./quirks2.html">go quirks &amp; tricks, pt 2</a> <a href="./quirks2.md">markdown</a></li>
</ul>

<h4>On: Go, Programming Languages</h4>

<p>Go is generally considered a ‘simple’ language, but it has more edge cases and tricks than most might expect.</p>

<p>You can be a productive go programmer without knowing about or using most or any of these tricks, but some of them are pretty handy. I’ll link to the <a href="https://go.dev/ref/spec">go spec</a> where appropriate throughout the article.</p>

<p>This is part 1 of what I hope to be a continuing series.</p>

<h2>multi-statement lines with semicolons</h2>

<p>Go is secretly a C-like language that terminates statements with semicolons. <a href="https://go.dev/doc/effective_go#semicolons">The semicolons are actually <em>inserted</em> early in compilation (during lexing)</a>. This means you can put multiple statements on the same line by inserting semicolons!</p>

<p>Be warned: <code>gofmt</code> will usually break them up into multiple lines. In fact, you can <em>never</em> have a single-line conditional. (Sorry, ternary conditional fans.)</p>

<p>Still, it can be handy for <em>really</em> small two-statement functions, like in tests:</p>

<pre><code class="language-go"><span class="kwd">func</span> <span class="pln">asJson</span><span class="pun">(</span><span class="pln">v</span> <span class="pln">any</span><span class="pun">)</span> <span class="pun">[</span><span class="pun">]</span><span class="kwd">byte</span> <span class="pun">{</span><span class="pln">b</span><span class="pun">,</span> <span class="pln">_</span> <span class="pun">:</span><span class="pun">=</span> <span class="pln">json</span><span class="pun">.</span><span class="typ">Marshal</span><span class="pun">(</span><span class="pln">v</span><span class="pun">)</span><span class="pun">;</span> <span class="kwd">return</span> <span class="pln">b</span><span class="pun">}</span>
</code></pre>

<h2>methods as functions (“method expressions”)</h2>

<p>Go methods are just functions. Given a type and method:</p>

<pre><code class="language-go"><span class="kwd">type</span> <span class="typ">Point</span> <span class="kwd">struct</span><span class="pun">{</span><span class="typ">X</span><span class="pun">,</span> <span class="typ">Y</span> <span class="kwd">float64</span><span class="pun">}</span>
<span class="kwd">func</span> <span class="pun">(</span><span class="pln">p</span> <span class="typ">Point</span><span class="pun">)</span> <span class="typ">Add</span><span class="pun">(</span><span class="pln">q</span> <span class="typ">Point</span><span class="pun">)</span> <span class="typ">Point</span><span class="pun">{</span> 
    <span class="kwd">return</span> <span class="typ">Point</span><span class="pun">{</span><span class="typ">X</span><span class="pun">:</span> <span class="pln">p</span><span class="pun">.</span><span class="typ">X</span><span class="pun">+</span><span class="pln">q</span><span class="pun">.</span><span class="typ">X</span><span class="pun">,</span> <span class="typ">Y</span><span class="pun">:</span> <span class="pln">p</span><span class="pun">.</span><span class="typ">Y</span><span class="pun">+</span><span class="pln">q</span><span class="pun">.</span><span class="typ">Y</span><span class="pun">}</span>
<span class="pun">}</span>
</code></pre>

<p>You can call the method in the ‘usual’ way by providing a receiver and using <code>receiver.funcName(arg1, arg2, ...)</code></p>

<pre><code class="language-go"><span class="pln">p</span><span class="pun">,</span> <span class="pln">q</span> <span class="pun">:</span><span class="pun">=</span> <span class="typ">Point</span><span class="pun">{</span><span class="dec">1</span><span class="pun">,</span> <span class="dec">1</span><span class="pun">}</span><span class="pun">,</span> <span class="typ">Point</span><span class="pun">{</span><span class="dec">2</span><span class="pun">,</span><span class="dec">2</span><span class="pun">}</span>
<span class="pln">fmt</span><span class="pun">.</span><span class="typ">Println</span><span class="pun">(</span><span class="pln">p</span><span class="pun">.</span><span class="typ">Add</span><span class="pun">(</span><span class="pln">q</span><span class="pun">)</span><span class="pun">)</span>
</code></pre>

<blockquote>
<p>out: <code>{3 3}</code></p>
</blockquote>

<p>Or you can use the method as an ordinary, “bare” function via <code>typeName.funcName(arg0, arg1, arg2</code>)</p>

<pre><code class="language-go"><span class="pln">p</span><span class="pun">,</span> <span class="pln">q</span> <span class="pun">:</span><span class="pun">=</span> <span class="typ">Point</span><span class="pun">{</span><span class="dec">1</span><span class="pun">,</span> <span class="dec">1</span><span class="pun">}</span><span class="pun">,</span> <span class="typ">Point</span><span class="pun">(</span><span class="dec">2</span><span class="pun">,</span><span class="dec">2</span><span class="pun">)</span><span class="pun">;</span> 
<span class="pln">fmt</span><span class="pun">.</span><span class="typ">Println</span><span class="pun">(</span><span class="typ">Point</span><span class="pun">.</span><span class="typ">Add</span><span class="pun">(</span><span class="pln">p</span><span class="pun">,</span> <span class="pln">q</span><span class="pun">)</span><span class="pun">)</span>
</code></pre>

<blockquote>
<p>out: <code>{3, 3}</code></p>
</blockquote>

<p>This is called a <a href="https://go.dev/ref/spec#Method_expressions">method expression</a>. Unlike method calls, a method <em>expression</em> won’t automatically reference or de-reference a receiver for you, since there <em>is</em> no receiver.</p>

<p>That is, while <strong>this</strong> code compiles fine</p>

<pre><code class="language-go"><span class="kwd">import</span> <span class="str">&#34;math/big&#34;</span> <span class="com">// https://go.dev/play/p/-CHMNxIKumy</span>
<span class="kwd">func</span> <span class="pln">main</span><span class="pun">(</span><span class="pun">)</span> <span class="pun">{</span>
 <span class="kwd">var</span> <span class="pln">x</span> <span class="pln">big</span><span class="pun">.</span><span class="typ">Float</span>
 <span class="pln">x</span><span class="pun">.</span><span class="typ">SetFloat64</span><span class="pun">(</span><span class="dec">10</span><span class="pun">)</span>
<span class="pun">}</span>
</code></pre>

<p><strong>This</strong> code gives a compiler error</p>

<pre><code class="language-go"><span class="kwd">import</span> <span class="str">&#34;math/big&#34;</span> <span class="com">// https://go.dev/play/p/cv8TSURe15J</span>
<span class="kwd">func</span> <span class="pln">main</span><span class="pun">(</span><span class="pun">)</span> <span class="pun">{</span>
 <span class="kwd">var</span> <span class="pln">x</span> <span class="pln">big</span><span class="pun">.</span><span class="typ">Float</span>
 <span class="pln">big</span><span class="pun">.</span><span class="typ">Float</span><span class="pun">.</span><span class="typ">SetFloat64</span><span class="pun">(</span><span class="pln">x</span><span class="pun">,</span> <span class="dec">10</span><span class="pun">)</span> <span class="com">// wrong</span>
<span class="pun">}</span>

</code></pre>

<blockquote>
<p>compiler error: <code>invalid method expression big.Float.SetFloat64 (needs pointer receiver (*big.Float).SetFloat64)</code></p>
</blockquote>

<p>The proper method expression is as follows</p>

<pre><code class="language-go"><span class="kwd">import</span> <span class="str">&#34;math/big&#34;</span> <span class="com">// https://go.dev/play/p/SRYxpp1UdVJ</span>
<span class="kwd">func</span> <span class="pln">main</span><span class="pun">(</span><span class="pun">)</span> <span class="pun">{</span>
 <span class="kwd">var</span> <span class="pln">x</span> <span class="pln">big</span><span class="pun">.</span><span class="typ">Float</span>
 <span class="pun">(</span><span class="pun">*</span><span class="pln">big</span><span class="pun">.</span><span class="typ">Float</span><span class="pun">)</span><span class="pun">.</span><span class="typ">SetFloat64</span><span class="pun">(</span><span class="pun">&amp;</span><span class="pln">x</span><span class="pun">,</span> <span class="dec">10</span><span class="pun">)</span> <span class="com">// note parens</span>
<span class="pun">}</span>
</code></pre>

<p>Method expressions don’t come up often, but they can occasionally save some work when you’re sorting or deduping.</p>

<h2><code>select</code> statements have <code>break</code></h2>

<p><code>select</code> has no <code>continue</code>, but it <em>does</em> have <code>break</code>. This can lead to nasty bugs if you’re trying to break out of, say, an enclosing <code>switch</code> or loop. Use labels instead, as demonstrated by this code in the un-exported <code>filelock</code> package in go’s stdlib:</p>

<pre><code class="language-go"> <span class="com">// Wait until process Q has either failed or locked file B.</span>
 <span class="com">// Otherwise, P.2 might not block on file B as intended.</span>
<span class="pln">locked</span><span class="pun">:</span>
 <span class="kwd">for</span> <span class="pun">{</span>
  <span class="kwd">if</span> <span class="pln">_</span><span class="pun">,</span> <span class="pln">err</span> <span class="pun">:</span><span class="pun">=</span> <span class="pln">os</span><span class="pun">.</span><span class="typ">Stat</span><span class="pun">(</span><span class="pln">filepath</span><span class="pun">.</span><span class="typ">Join</span><span class="pun">(</span><span class="pln">dir</span><span class="pun">,</span> <span class="str">&#34;locked&#34;</span><span class="pun">)</span><span class="pun">)</span><span class="pun">;</span> <span class="pun">!</span><span class="pln">os</span><span class="pun">.</span><span class="typ">IsNotExist</span><span class="pun">(</span><span class="pln">err</span><span class="pun">)</span> <span class="pun">{</span>
   <span class="kwd">break</span> <span class="pln">locked</span>
  <span class="pun">}</span>
  <span class="pln">select</span> <span class="pun">{</span>
  <span class="kwd">case</span> <span class="pun">&lt;</span><span class="pun">-</span><span class="pln">qDone</span><span class="pun">:</span>
   <span class="kwd">break</span> <span class="pln">locked</span>
  <span class="kwd">case</span> <span class="pun">&lt;</span><span class="pun">-</span><span class="pln">time</span><span class="pun">.</span><span class="typ">After</span><span class="pun">(</span><span class="dec">1</span> <span class="pun">*</span> <span class="pln">time</span><span class="pun">.</span><span class="typ">Millisecond</span><span class="pun">)</span><span class="pun">:</span>
  <span class="pun">}</span>
 <span class="pun">}</span>
</code></pre>

<h2>go can infer the type of composite literals in some contexts, but not others</h2>

<p>The following code <a href="https://go.dev/play/p/Bn8DbOzely0">playground</a> gives a terse and unhelpful compiler error:</p>

<pre><code class="language-go">
<span class="kwd">func</span> <span class="pln">main</span><span class="pun">(</span><span class="pun">)</span> <span class="pun">{</span> <span class="com">// https://go.dev/play/p/CLu4AXg5qYW</span>
 <span class="kwd">type</span> <span class="typ">Q</span> <span class="kwd">struct</span><span class="pun">{</span> <span class="typ">A</span><span class="pun">,</span> <span class="typ">B</span> <span class="pun">[</span><span class="dec">3</span><span class="pun">]</span><span class="kwd">int</span> <span class="pun">}</span>
 <span class="pln">structOfArrays</span> <span class="pun">:</span><span class="pun">=</span> <span class="typ">Q</span><span class="pun">{</span><span class="pun">{</span><span class="pun">}</span><span class="pun">,</span> <span class="pun">{</span><span class="pun">}</span><span class="pun">}</span>
 <span class="pln">fmt</span><span class="pun">.</span><span class="typ">Println</span><span class="pun">(</span><span class="pln">structOfArrays</span><span class="pun">)</span>
<span class="pun">}</span>
</code></pre>

<blockquote>
<p>compiler error: <code>missing type in composite literal</code></p>
</blockquote>

<p>This implies that you always need to provide the types of composite literals, but that’s just not true. Go is happy to compile the following bode without me spelling out the type of each item on the right-hand side:</p>

<pre><code class="language-go"><span class="kwd">func</span> <span class="pln">main</span><span class="pun">(</span><span class="pun">)</span> <span class="pun">{</span> <span class="com">// https://go.dev/play/p/CLu4AXg5qYW</span>
 <span class="kwd">type</span> <span class="typ">S</span> <span class="kwd">struct</span><span class="pun">{</span> <span class="typ">N</span><span class="pun">,</span> <span class="typ">M</span> <span class="kwd">int</span> <span class="pun">}</span>
 <span class="pln">arrayOfStructs</span> <span class="pun">:</span><span class="pun">=</span> <span class="pun">[</span><span class="dec">3</span><span class="pun">]</span><span class="typ">S</span><span class="pun">{</span><span class="pun">{</span><span class="pun">}</span><span class="pun">,</span> <span class="pun">{</span><span class="pun">}</span><span class="pun">,</span> <span class="pun">{</span><span class="dec">0</span><span class="pun">,</span> <span class="dec">1</span><span class="pun">}</span><span class="pun">}</span>
 <span class="pln">fmt</span><span class="pun">.</span><span class="typ">Println</span><span class="pun">(</span><span class="pln">arrayOfStructs</span><span class="pun">)</span>
<span class="pun">}</span>
</code></pre>

<blockquote>
<p>out: <code>[{0 0} {0 0} {0 1}]</code></p>
</blockquote>

<p>Or even this monstrosity:</p>

<pre><code class="language-go"><span class="kwd">func</span> <span class="pln">main</span><span class="pun">(</span><span class="pun">)</span> <span class="pun">{</span> <span class="com">// https://go.dev/play/p/kXLR8n7WdMc</span>
 <span class="pln">sliceOfMapOfArrayOfStructs</span> <span class="pun">:</span><span class="pun">=</span> <span class="pun">[</span><span class="pun">]</span><span class="kwd">map</span><span class="pun">[</span><span class="pln">string</span><span class="pun">]</span><span class="pun">[</span><span class="dec">2</span><span class="pun">]</span><span class="kwd">struct</span><span class="pun">{</span> <span class="typ">N</span><span class="pun">,</span> <span class="typ">M</span> <span class="kwd">int</span> <span class="pun">}</span><span class="pun">{</span><span class="pun">{</span><span class="str">&#34;foo&#34;</span><span class="pun">:</span> <span class="pun">{</span><span class="pun">{</span><span class="pun">}</span><span class="pun">,</span> <span class="pun">{</span><span class="typ">M</span><span class="pun">:</span> <span class="dec">2</span><span class="pun">}</span><span class="pun">}</span><span class="pun">}</span><span class="pun">}</span>
 <span class="pln">fmt</span><span class="pun">.</span><span class="typ">Printf</span><span class="pun">(</span><span class="str">&#34;%+v\n&#34;</span><span class="pun">,</span> <span class="pln">sliceOfMapOfArrayOfStructs</span><span class="pun">)</span>
<span class="pun">}</span>

</code></pre>

<blockquote>
<p>out: <code>[map[foo:[{N:0 M:0} {N:0 M:2}]]]</code></p>
</blockquote>

<p>The actual rule is this: go will infer the types of composite literals if they’re contained within an <strong>array</strong>, <strong>map</strong>, or <strong>slice</strong>, but struct fields and function arguments always need to spelled out explicitly.</p>

<p>There’s a long-open <a href="https://github.com/golang/go/issues/12854">issue (#12584)</a> hoping to address this inconsistency. I’d love to see more permissive composite literals.</p>

<h2>simple expressions in switch statements</h2>

<p>A switch statement <a href="https://go.dev/ref/spec#Switch_statements">can be proceeded by a simple statement</a>:</p>

<pre><code class="language-go"><span class="com">// b is a *math/big.Int*</span>
<span class="kwd">switch</span> <span class="pln">n</span><span class="pun">,</span> <span class="pln">acc</span> <span class="pun">:</span><span class="pun">=</span> <span class="pln">b</span><span class="pun">.</span><span class="typ">Uint64</span><span class="pun">(</span><span class="pun">)</span><span class="pun">;</span> <span class="pln">acc</span> <span class="pun">{</span>
    <span class="kwd">case</span> <span class="pln">big</span><span class="pun">.</span><span class="typ">Below</span><span class="pun">:</span>
        <span class="pln">fmt</span><span class="pun">.</span><span class="typ">Println</span><span class="pun">(</span><span class="str">&#34;&lt; 0&#34;</span><span class="pun">)</span><span class="pun">,</span>
    <span class="kwd">case</span> <span class="pln">big</span><span class="pun">.</span><span class="typ">Above</span><span class="pun">:</span>
        <span class="pln">fmt</span><span class="pun">.</span><span class="typ">Println</span><span class="pun">(</span><span class="str">&#34;&gt; 18446744073709551615&#34;</span><span class="pun">)</span>
    <span class="kwd">case</span> <span class="pln">big</span><span class="pun">.</span><span class="typ">Exact</span><span class="pun">:</span>
        <span class="pln">fmt</span><span class="pun">.</span><span class="typ">Println</span><span class="pun">(</span><span class="pln">n</span><span class="pun">)</span>
<span class="pun">}</span>
</code></pre>

<p>This works for expression switches and type switches:</p>

<pre><code class="language-go"><span class="kwd">switch</span> <span class="pln">a</span><span class="pun">,</span> <span class="pln">err</span> <span class="pun">:</span><span class="pun">=</span> <span class="pln">f</span><span class="pun">(</span><span class="pun">)</span><span class="pun">;</span> <span class="pln">err</span><span class="pun">.</span><span class="pun">(</span><span class="kwd">type</span><span class="pun">)</span> <span class="pun">{</span>
<span class="pun">}</span>
</code></pre>

<p>If you omit the <em>second</em> part of the switch, you can do a “normal” boolean-value switch statement:</p>

<pre><code class="language-go"><span class="com">// some kind of low-level networking call:</span>
<span class="kwd">var</span> <span class="kwd">try</span> <span class="kwd">int</span>
<span class="kwd">var</span> <span class="pln">packets</span> <span class="pun">[</span><span class="pun">]</span><span class="typ">Packet</span>
<span class="typ">READ</span><span class="pun">:</span>
<span class="kwd">for</span> <span class="pun">{</span>
    <span class="kwd">switch</span> <span class="pln">packet</span><span class="pun">,</span> <span class="pln">err</span> <span class="pun">:</span><span class="pun">=</span> <span class="pln">readPacket</span><span class="pun">(</span><span class="pln">ctx</span><span class="pun">,</span> <span class="pln">conn</span><span class="pun">,</span> <span class="pln">buf</span><span class="pun">)</span><span class="pun">;</span>  <span class="pun">{</span> <span class="com">// note semicolon</span>
        <span class="kwd">case</span> <span class="pln">errors</span><span class="pun">.</span><span class="typ">Is</span><span class="pun">(</span><span class="pln">err</span><span class="pun">,</span> <span class="pln">io</span><span class="pun">.</span><span class="typ">EOF</span><span class="pun">)</span><span class="pun">:</span> 
            <span class="pln">packets</span> <span class="pun">=</span> <span class="kwd">append</span><span class="pun">(</span><span class="pln">packets</span><span class="pun">,</span> <span class="pln">packet</span><span class="pun">)</span>
            <span class="kwd">break</span> <span class="typ">READ</span>
        <span class="kwd">case</span> <span class="pln">err</span> <span class="pun">=</span><span class="pun">=</span> <span class="kwd">nil</span><span class="pun">:</span>
            <span class="pln">packets</span> <span class="pun">=</span> <span class="kwd">append</span><span class="pun">(</span><span class="pln">packets</span><span class="pun">,</span> <span class="pln">packet</span><span class="pun">)</span>
            <span class="kwd">try</span> <span class="pun">=</span> <span class="dec">0</span>
        <span class="kwd">case</span> <span class="pln">errors</span><span class="pun">.</span><span class="typ">As</span><span class="pun">(</span><span class="pln">err</span><span class="pun">,</span> <span class="pln">fatalErr</span><span class="pun">)</span> <span class="pun">|</span><span class="pun">|</span> <span class="kwd">try</span> <span class="pun">=</span><span class="pun">=</span> <span class="pln">maxTries</span><span class="pun">:</span>
            <span class="kwd">return</span> <span class="pln">fmt</span><span class="pun">.</span><span class="typ">Errorf</span><span class="pun">(</span><span class="str">&#34;fatal error after %d retries: %v&#34;</span><span class="pun">,</span> <span class="pln">i</span><span class="pun">,</span> <span class="pln">err</span><span class="pun">)</span>
        <span class="kwd">default</span><span class="pun">:</span>
            <span class="kwd">const</span> <span class="pln">wait</span> <span class="pun">=</span> <span class="dec">100</span><span class="pun">*</span><span class="pln">time</span><span class="pun">.</span><span class="typ">Millisecond</span>
            <span class="pln">log</span><span class="pun">.</span><span class="typ">Printf</span><span class="pun">(</span><span class="str">&#34;error: retrying in %d&#34;</span><span class="pun">,</span> <span class="pln">wait</span><span class="pun">)</span>
            <span class="kwd">try</span><span class="pun">+</span><span class="pun">+</span>
            <span class="pln">time</span><span class="pun">.</span><span class="typ">Sleep</span><span class="pun">(</span><span class="pln">wait</span><span class="pun">)</span>
    <span class="pun">}</span>
<span class="pun">}</span>

</code></pre>

<p>I like the look of these: they allow very terse, expressive code, but they’re rare &amp; unusual enough to probably cause confusion. Most of the time you’re better off with a chain of <code>if</code>.</p>

<h2>GOTO exists</h2>

<p>The oft-maligned GOTO is an excellent piece of kit. Go’s GOTO is somewhat limited: you can’t jump into a new block or out of a function, so it’s hard to get yourself into the kind of trouble you could in 1980s BASIC.</p>

<p>This means you can’t do something like this, since you’ll get a compiler error:</p>

<pre><code class="language-go">
<span class="kwd">func</span> <span class="pln">main</span><span class="pun">(</span><span class="pun">)</span> <span class="pun">{</span> <span class="com">// https://go.dev/play/p/1krGFE6FvgJ</span>
 <span class="kwd">goto</span> <span class="pln">label</span>

 <span class="kwd">if</span> <span class="kwd">true</span> <span class="pun">{</span>
  <span class="pln">v</span> <span class="pun">:</span><span class="pun">=</span> <span class="dec">3</span>
  <span class="pln">panic</span><span class="pun">(</span><span class="pln">v</span><span class="pun">)</span>

 <span class="pln">label</span><span class="pun">:</span>
  <span class="pln">fmt</span><span class="pun">.</span><span class="typ">Println</span><span class="pun">(</span><span class="pln">v</span><span class="pun">)</span> <span class="com">// what&#39;s the value of v?</span>
 <span class="pun">}</span>
<span class="pun">}</span>


</code></pre>

<blockquote>
<p>compiler error: <code>./prog.go:11:7: goto label jumps into block starting at ./prog.go:13:10</code></p>
</blockquote>

<p>Speaking of which:</p>

<h2>you can make a block at any time</h2>

<p>You don’t need an <code>if</code>, <code>for</code>, <code>func</code>, or any other keyword to make a block.</p>

<pre><code class="language-go"><span class="pun">{</span>
    <span class="pln">name</span> <span class="pun">:</span><span class="pun">=</span> <span class="str">&#34;efron&#34;</span>
    <span class="pun">{</span>
        <span class="pln">fmt</span><span class="pun">.</span><span class="typ">Println</span><span class="pun">(</span><span class="str">&#34;hi &#34;</span><span class="pun">,</span> <span class="pln">name</span><span class="pun">)</span>
    <span class="pun">}</span>
<span class="pun">}</span>

</code></pre>

<p>I find this useful for complicated variable initialization. Here’s an example from the <code>fmtbench</code> tool I wrote in <a href="./bytehacking.html">the last article</a></p>

<pre><code class="language-go"><span class="com">// fmtbench.go</span>
<span class="com">// context: the variable sortBy is a command-line flag specifying the sort order. we&#39;ve already validated it.</span>
<span class="com">// results is a []struct{</span>
<span class="com">//     name                    string,</span>
<span class="com">//  runs, ns, bytes, allocs float64</span>
<span class="com">// }</span>
<span class="pun">{</span>
 <span class="com">// sort results</span>
  <span class="kwd">var</span> <span class="pln">less</span> <span class="kwd">func</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span> <span class="pln">j</span> <span class="kwd">int</span><span class="pun">)</span> <span class="kwd">bool</span>
  <span class="kwd">switch</span> <span class="pun">*</span><span class="pln">sortBy</span> <span class="pun">{</span>
  <span class="kwd">default</span><span class="pun">:</span>
    <span class="kwd">goto</span> <span class="typ">PRINT</span>
  <span class="kwd">case</span> <span class="str">&#34;allocs&#34;</span><span class="pun">:</span>
   <span class="pln">less</span> <span class="pun">=</span> <span class="kwd">func</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span> <span class="pln">j</span> <span class="kwd">int</span><span class="pun">)</span> <span class="kwd">bool</span> <span class="pun">{</span> <span class="kwd">return</span> <span class="pln">results</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pun">.</span><span class="pln">allocs</span> <span class="pun">&lt;</span> <span class="pln">results</span><span class="pun">[</span><span class="pln">j</span><span class="pun">]</span><span class="pun">.</span><span class="pln">allocs</span> <span class="pun">}</span>
  <span class="kwd">case</span> <span class="str">&#34;name&#34;</span><span class="pun">:</span>
   <span class="pln">less</span> <span class="pun">=</span> <span class="kwd">func</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span> <span class="pln">j</span> <span class="kwd">int</span><span class="pun">)</span> <span class="kwd">bool</span> <span class="pun">{</span> <span class="kwd">return</span> <span class="pln">results</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pun">.</span><span class="pln">name</span> <span class="pun">&lt;</span> <span class="pln">results</span><span class="pun">[</span><span class="pln">j</span><span class="pun">]</span><span class="pun">.</span><span class="pln">name</span> <span class="pun">}</span>
  <span class="kwd">case</span> <span class="str">&#34;runtime&#34;</span><span class="pun">:</span>
   <span class="pln">less</span> <span class="pun">=</span> <span class="kwd">func</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span> <span class="pln">j</span> <span class="kwd">int</span><span class="pun">)</span> <span class="kwd">bool</span> <span class="pun">{</span> <span class="kwd">return</span> <span class="pln">results</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pun">.</span><span class="pln">ns</span> <span class="pun">&lt;</span> <span class="pln">results</span><span class="pun">[</span><span class="pln">j</span><span class="pun">]</span><span class="pun">.</span><span class="pln">ns</span> <span class="pun">}</span>
  <span class="pun">}</span>
  <span class="pln">sort</span><span class="pun">.</span><span class="typ">Slice</span><span class="pun">(</span><span class="pln">results</span><span class="pun">,</span> <span class="pln">less</span><span class="pun">)</span>
 <span class="pun">}</span>
<span class="typ">PRINT</span><span class="pun">:</span>
 <span class="kwd">for</span> <span class="pln">_</span><span class="pun">,</span> <span class="pln">res</span> <span class="pun">:</span><span class="pun">=</span> <span class="pln">range</span> <span class="pln">results</span> <span class="pun">{</span>
  <span class="pln">fmt</span><span class="pun">.</span><span class="typ">Printf</span><span class="pun">(</span><span class="str">&#34;|%s|%.3g|%.3g|%0.3g|%.3g|%0.3g|%.3g|%0.3g|\n&#34;</span><span class="pun">,</span> <span class="pln">res</span><span class="pun">.</span><span class="pln">name</span><span class="pun">,</span> <span class="pln">res</span><span class="pun">.</span><span class="pln">runs</span><span class="pun">,</span> <span class="pln">res</span><span class="pun">.</span><span class="pln">ns</span><span class="pun">,</span> <span class="pun">(</span><span class="pln">res</span><span class="pun">.</span><span class="pln">ns</span><span class="pun">/</span><span class="pln">maxNS</span><span class="pun">)</span><span class="pun">*</span><span class="dec">100</span><span class="pun">,</span> <span class="pln">res</span><span class="pun">.</span><span class="pln">bytes</span><span class="pun">,</span> <span class="pun">(</span><span class="pln">res</span><span class="pun">.</span><span class="pln">bytes</span><span class="pun">/</span><span class="pln">maxBytes</span><span class="pun">)</span><span class="pun">*</span><span class="dec">100</span><span class="pun">,</span> <span class="pln">res</span><span class="pun">.</span><span class="pln">allocs</span><span class="pun">,</span> <span class="pun">(</span><span class="pln">res</span><span class="pun">.</span><span class="pln">allocs</span><span class="pun">/</span><span class="pln">maxAllocs</span><span class="pun">)</span><span class="pun">*</span><span class="dec">100</span><span class="pun">)</span>
 <span class="pun">}</span>
</code></pre>

<p>By using a block here, we make it immediately clear that <code>less</code> is only going to exist for the context of this sort</p>

<p>We <em>could</em> make a function for this, but that means jumping around, for us, the compiler, and the runtime (assuming it’s not inlined).</p>

<p>Try starting with blocks, and promote them to functions when you find yourself needing to re-use the code.</p>

<p>But sometimes you do need a function, even for a single use:</p>

<h2>immediately-evaluated-function-expressions</h2>

<p>You can define a function and invoke it on the same line:</p>

<pre><code class="language-go"><span class="com">// playground: https://go.dev/play/p/dmNloKFUGSZ</span>
<span class="kwd">package</span> <span class="pln">main</span>

<span class="kwd">import</span> <span class="pun">(</span>
 <span class="str">&#34;crypto/rand&#34;</span>
 <span class="str">&#34;encoding/binary&#34;</span>
 <span class="str">&#34;fmt&#34;</span>
<span class="pun">)</span>

<span class="kwd">var</span> <span class="pln">seed</span> <span class="pln">uint64</span> <span class="pun">=</span> <span class="kwd">func</span><span class="pun">(</span><span class="pun">)</span> <span class="pln">uint64</span> <span class="pun">{</span>
 <span class="kwd">var</span> <span class="pln">b</span> <span class="pun">=</span> <span class="kwd">make</span><span class="pun">(</span><span class="pun">[</span><span class="pun">]</span><span class="kwd">byte</span><span class="pun">,</span> <span class="dec">8</span><span class="pun">)</span>
 <span class="pln">_</span><span class="pun">,</span> <span class="pln">_</span> <span class="pun">=</span> <span class="pln">rand</span><span class="pun">.</span><span class="typ">Read</span><span class="pun">(</span><span class="pln">b</span><span class="pun">)</span>
 <span class="kwd">return</span> <span class="pln">binary</span><span class="pun">.</span><span class="typ">LittleEndian</span><span class="pun">.</span><span class="typ">Uint64</span><span class="pun">(</span><span class="pln">b</span><span class="pun">)</span>
<span class="pun">}</span><span class="pun">(</span><span class="pun">)</span>

<span class="kwd">func</span> <span class="pln">main</span><span class="pun">(</span><span class="pun">)</span> <span class="pun">{</span>
 <span class="pln">fmt</span><span class="pun">.</span><span class="typ">Println</span><span class="pun">(</span><span class="pln">seed</span><span class="pun">)</span>
<span class="pun">}</span>
</code></pre>

<p>This is the catchily-named “immediately-evaluated-function-expression”, or IIFE for short. These are invaluable in languages which privelege functions over other kinds of blocks: for example, Javascript before it got the <code>let</code> keyword had no block scope, so you had to define functions every time you wanted a new namespace.</p>

<p>Go privleges functions over blocks in two ways:</p>

<ul>
<li>you can evaluate a function during variable declarations in the global namespace (that is, before <code>main()</code> or even <code>init()</code>, as shown in the example above.</li>
<li>a <code>defer</code>-ed function evaluates at the end of the enclosing <em>function</em> scope.</li>
</ul>

<p>There’s basically only two uses for IIFE’s instead of blocks:</p>

<ul>
<li>for complex variable initialization in the global scope in a more natural way than using <code>init()</code>.</li>
<li>if you need a function scope to use <code>defer()</code> or <code>recover()</code>, since</li>
</ul>

<p>If you’re going to use an IIFE with a return value, use the <code>var</code> declaration instead of <code>:=</code> - it makes it easier for the reader to understand the flow. And don’t overdo it - you can always just define a closure and call it on the next line.</p>

<h2>you can declare types inside blocks</h2>

<p>You can declare types inside any kind of block, but you can’t declare methods on those types.
You <em>can</em> define a function that takes that type using a function expression (“closure”).</p>

<pre><code class="language-go"><span class="kwd">import</span> <span class="str">&#34;fmt&#34;</span>
<span class="kwd">func</span> <span class="pln">main</span><span class="pun">(</span><span class="pun">)</span> <span class="pun">{</span> <span class="com">// playground: https://go.dev/play/p/vAkgOTnEg7d</span>
 <span class="kwd">type</span> <span class="typ">Point</span> <span class="kwd">struct</span><span class="pun">{</span> <span class="typ">X</span><span class="pun">,</span> <span class="typ">Y</span> <span class="kwd">float64</span> <span class="pun">}</span>
 <span class="pln">addPoint</span> <span class="pun">:</span><span class="pun">=</span> <span class="kwd">func</span><span class="pun">(</span><span class="pln">p</span><span class="pun">,</span> <span class="pln">q</span> <span class="typ">Point</span><span class="pun">)</span> <span class="typ">Point</span> <span class="pun">{</span> <span class="kwd">return</span> <span class="typ">Point</span><span class="pun">{</span><span class="pln">p</span><span class="pun">.</span><span class="typ">X</span> <span class="pun">+</span> <span class="pln">q</span><span class="pun">.</span><span class="typ">X</span><span class="pun">,</span> <span class="pln">p</span><span class="pun">.</span><span class="typ">Y</span> <span class="pun">+</span> <span class="pln">q</span><span class="pun">.</span><span class="typ">Y</span><span class="pun">}</span> <span class="pun">}</span>
 <span class="pln">q</span> <span class="pun">:</span><span class="pun">=</span> <span class="pln">addPoint</span><span class="pun">(</span><span class="typ">Point</span><span class="pun">{</span><span class="dec">2</span><span class="pun">,</span> <span class="dec">3</span><span class="pun">}</span><span class="pun">,</span> <span class="typ">Point</span><span class="pun">{</span><span class="pun">-</span><span class="dec">1</span><span class="pun">,</span> <span class="dec">1</span><span class="pun">}</span><span class="pun">)</span>
 <span class="pln">fmt</span><span class="pun">.</span><span class="typ">Println</span><span class="pun">(</span><span class="pln">q</span><span class="pun">)</span>
<span class="pun">}</span>

</code></pre>

<blockquote>
<p>output:  <code>{1 4}</code></p>
</blockquote>

<p>This obeys the ordinary block-scope rules, so this would be a compiler error:</p>

<pre><code class="language-go"><span class="kwd">func</span> <span class="pln">main</span><span class="pun">(</span><span class="pun">)</span> <span class="pun">{</span> <span class="com">// https://go.dev/play/p/_ytvmPewLTA</span>
    <span class="pun">{</span>
        <span class="kwd">type</span> <span class="typ">Point</span> <span class="kwd">struct</span><span class="pun">{</span><span class="typ">X</span><span class="pun">,</span> <span class="typ">Y</span> <span class="kwd">float64</span><span class="pun">}</span>
    <span class="pun">}</span>
    <span class="kwd">var</span> <span class="pln">p</span> <span class="typ">Point</span> 
<span class="pun">}</span>
</code></pre>

<blockquote>
<p>compiler error: <code>./prog.go:9:8: undefined: Point</code></p>
</blockquote>

<p>This can make your code more straightforward. Just like variables, it’s best to define a type as close to it’s use and with as small of a scope as possible.</p>

<h2>go has anonymous structs</h2>

<p>Sometimes you don’t have to declare the type at all: go allows anonymous struct values. This is especially handy for functions like <code>json.Marshal</code> and <code>json.Unmarshal</code> which just depend on the <em>shape</em> of the type.</p>

<p>These anonymous structs can <em>nest</em>:</p>

<pre><code class="language-go"><span class="kwd">func</span> <span class="pln">main</span><span class="pun">(</span><span class="pun">)</span> <span class="pun">{</span> <span class="com">// https://go.dev/play/p/vA5SJ-GKJMm</span>
 <span class="kwd">var</span> <span class="pln">s</span> <span class="kwd">struct</span><span class="pun">{</span> <span class="typ">Name</span> <span class="kwd">struct</span><span class="pun">{</span> <span class="typ">First</span><span class="pun">,</span> <span class="typ">Last</span> <span class="pln">string</span> <span class="pun">}</span> <span class="pun">}</span>
 <span class="pln">json</span><span class="pun">.</span><span class="typ">Unmarshal</span><span class="pun">(</span><span class="pun">[</span><span class="pun">]</span><span class="kwd">byte</span><span class="pun">(</span><span class="str">`{&#34;name&#34;: {&#34;first&#34;: &#34;efron&#34;, &#34;last&#34;: &#34;licht&#34;}}`</span><span class="pun">)</span><span class="pun">,</span> <span class="pun">&amp;</span><span class="pln">s</span><span class="pun">)</span>
 <span class="pln">fmt</span><span class="pun">.</span><span class="typ">Printf</span><span class="pun">(</span><span class="str">&#34;%+v\n&#34;</span><span class="pun">,</span> <span class="pln">s</span><span class="pun">)</span>
<span class="pun">}</span>
</code></pre>

<blockquote>
<p>output: <code>{Name:{First:efron Last:licht}}</code></p>
</blockquote>

<p>You can even make custom struct tags for your individual use case:</p>

<pre><code class="language-go"><span class="com">// GET /health</span>
<span class="kwd">import</span> <span class="str">&#34;json&#34;</span>
<span class="kwd">import</span> <span class="str">&#34;net/http&#34;</span>
<span class="kwd">func</span> <span class="typ">WriteHealth</span><span class="pun">(</span><span class="pln">w</span> <span class="pln">http</span><span class="pun">.</span><span class="typ">ResponseWriter</span><span class="pun">,</span> <span class="pln">_</span> <span class="pun">*</span><span class="pln">http</span><span class="pun">.</span><span class="typ">Request</span><span class="pun">)</span> <span class="pun">{</span>
    <span class="pln">json</span><span class="pun">.</span><span class="typ">NewEncoder</span><span class="pun">(</span><span class="pln">w</span><span class="pun">)</span><span class="pun">.</span><span class="typ">Encode</span><span class="pun">(</span><span class="kwd">struct</span> <span class="pun">{</span>
        <span class="typ">Uptime</span> <span class="pln">time</span><span class="pun">.</span><span class="typ">Duration</span> <span class="str">`json:&#34;uptime&#34;`</span>
        <span class="typ">Stats</span> <span class="kwd">struct</span> <span class="pun">{</span>
            <span class="typ">Hits</span> <span class="kwd">int64</span> <span class="str">`json:&#34;hits&#34;`</span>
            <span class="typ">Misses</span> <span class="kwd">int64</span> <span class="str">`json:&#34;misses&#34;`</span>
            <span class="typ">Errors</span> <span class="kwd">int64</span> <span class="str">`json:&#34;errors&#34;`</span>
        <span class="pun">}</span> <span class="str">`json:&#34;stats&#34;`</span>
    <span class="pun">}</span><span class="pun">)</span>
<span class="pun">}</span>
</code></pre>

<h2>… and anonymous interfaces</h2>

<p>You <em>never</em> have to declare the type of an interface: anywhere you can use <code>io.Writer</code>, you can use <code>interface{Write([]byte)(int, error)}</code>.</p>

<p>This can be handy for runtime specialization (that is, when you want to check if a type fulfills extra interfaces)</p>

<pre><code class="language-go"><span class="kwd">import</span> <span class="str">&#34;gzip&#34;</span>
<span class="kwd">func</span> <span class="pln">writeZipped</span><span class="pun">(</span><span class="pln">w</span> <span class="pln">io</span><span class="pun">.</span><span class="typ">Writer</span><span class="pun">,</span> <span class="pln">b</span> <span class="pun">[</span><span class="pun">]</span><span class="kwd">byte</span><span class="pun">)</span> <span class="pun">(</span><span class="kwd">int</span><span class="pun">,</span> <span class="pln">error</span><span class="pun">)</span> <span class="pun">{</span>
    <span class="pln">zipw</span> <span class="pun">:</span><span class="pun">=</span> <span class="pln">gzip</span><span class="pun">.</span><span class="typ">NewWriter</span><span class="pun">(</span><span class="pln">w</span><span class="pun">)</span>
    <span class="pln">n</span><span class="pun">,</span> <span class="pln">err</span> <span class="pun">:</span><span class="pun">=</span> <span class="pln">zipw</span><span class="pun">.</span><span class="typ">Write</span><span class="pun">(</span><span class="pln">w</span><span class="pun">)</span>
    <span class="kwd">if</span> <span class="pln">err</span> <span class="pun">!</span><span class="pun">=</span> <span class="kwd">nil</span> <span class="pun">{</span>
        <span class="kwd">return</span> <span class="pln">n</span><span class="pun">,</span> <span class="pln">err</span>
    <span class="pun">}</span>
    <span class="kwd">if</span> <span class="pln">err</span> <span class="pun">:</span><span class="pun">=</span> <span class="pln">zipw</span><span class="pun">.</span><span class="typ">Close</span><span class="pun">(</span><span class="pun">)</span><span class="pun">;</span> <span class="pln">err</span> <span class="pun">!</span><span class="pun">=</span> <span class="kwd">nil</span> <span class="pun">{</span>
        <span class="kwd">return</span> <span class="pln">err</span>
    <span class="pun">}</span>
    <span class="com">// flush the underlying buffer, if there is one</span>
    <span class="kwd">if</span> <span class="pln">f</span><span class="pun">,</span> <span class="pln">ok</span> <span class="pun">:</span><span class="pun">=</span> <span class="pln">w</span><span class="pun">.</span><span class="pun">(</span><span class="kwd">interface</span><span class="pun">{</span><span class="typ">Flush</span><span class="pun">(</span><span class="pun">)</span> <span class="pln">error</span><span class="pun">}</span><span class="pun">)</span><span class="pun">;</span> <span class="pln">ok</span> <span class="pun">{</span>
        <span class="pln">_</span> <span class="pun">=</span> <span class="pln">f</span><span class="pun">.</span><span class="typ">Flush</span><span class="pun">(</span><span class="pun">)</span>
    <span class="pun">}</span>
    <span class="com">// sync to disk if possible</span>
    <span class="kwd">if</span> <span class="pln">f</span><span class="pun">,</span> <span class="pln">ok</span> <span class="pun">:</span><span class="pun">=</span> <span class="pln">w</span><span class="pun">.</span><span class="pun">(</span><span class="kwd">interface</span><span class="pun">{</span><span class="typ">Sync</span><span class="pun">(</span><span class="pun">)</span> <span class="pln">error</span><span class="pun">}</span><span class="pun">)</span><span class="pun">;</span> <span class="pln">ok</span> <span class="pun">{</span>
        <span class="pln">_</span> <span class="pun">=</span> <span class="pln">f</span><span class="pun">.</span><span class="typ">Sync</span><span class="pun">(</span><span class="pun">)</span>
    <span class="pun">}</span>
<span class="pun">}</span>
</code></pre>

<p>This is especially useful for function signatures. Suppose I’m going to call out to a database as part of a function.</p>

<p>(An aside: I don’t particularly like mocking: I’d love to write an article about strategies you can use to avoid it).</p>

<p>The ‘ordinary’ function signature would look something like this:</p>

<pre><code class="language-go"><span class="kwd">func</span> <span class="typ">SelectUser</span><span class="pun">(</span><span class="pln">ctx</span> <span class="pln">context</span><span class="pun">.</span><span class="typ">Context</span><span class="pun">,</span> <span class="pln">db</span> <span class="pun">*</span><span class="pln">sql</span><span class="pun">.</span><span class="typ">DB</span><span class="pun">,</span> <span class="pln">userID</span> <span class="pln">uuid</span><span class="pun">.</span><span class="typ">UUID</span><span class="pun">)</span> <span class="pun">(</span><span class="pln">username</span> <span class="pln">string</span><span class="pun">,</span> <span class="pln">createdAt</span> <span class="pln">time</span><span class="pun">.</span><span class="typ">Time</span><span class="pun">,</span> <span class="pln">err</span> <span class="pln">error</span><span class="pun">)</span> <span class="pun">{</span>
    <span class="kwd">const</span> <span class="pln">query</span> <span class="pun">=</span> <span class="str">`SELECT username, created_at FROM users where user.id = $1;`</span>
    <span class="pln">db</span><span class="pun">.</span><span class="typ">QueryRowContext</span><span class="pun">(</span><span class="pln">ctx</span><span class="pun">,</span> <span class="pln">query</span><span class="pun">,</span> <span class="pln">userID</span><span class="pun">)</span><span class="pun">.</span><span class="typ">Scan</span><span class="pun">(</span><span class="pun">&amp;</span><span class="pln">username</span><span class="pun">,</span> <span class="pln">createdAt</span><span class="pun">)</span>
<span class="pun">}</span>
</code></pre>

<p>Suppose at some point we need to mock this for a test. *sql.DB is a struct, and it’s not immediately apparent what we’d call the interface we’d replace it with. <code>DBer?</code> <code>QueryRowContexter</code>? In this case,  we can be clearest by omitting the name entirely: all the reader needs to know is that the DB has a function that looks like QueryRowContext().</p>

<p>We can make this mockable by just changing the function signature to use an <em>anonymous interface</em>.</p>

<pre><code class="language-go"><span class="kwd">func</span> <span class="typ">SelectUser</span><span class="pun">(</span>
    <span class="pln">ctx</span> <span class="pln">context</span><span class="pun">.</span><span class="typ">Context</span><span class="pun">,</span> 
    <span class="pln">db</span> <span class="kwd">interface</span><span class="pun">{</span><span class="typ">QueryRowContext</span><span class="pun">(</span><span class="pln">context</span><span class="pun">.</span><span class="typ">Context</span><span class="pun">,</span> <span class="pln">string</span><span class="pun">,</span> <span class="pun">.</span><span class="pun">.</span><span class="pun">.</span><span class="pln">args</span><span class="pun">)</span> <span class="pun">*</span><span class="pln">sql</span><span class="pun">.</span><span class="typ">Row</span><span class="pun">}</span><span class="pun">,</span>
    <span class="pln">userID</span> <span class="pln">uuid</span><span class="pun">.</span><span class="typ">UUID</span>
<span class="pun">)</span> <span class="pun">(</span><span class="pln">username</span> <span class="pln">string</span><span class="pun">,</span> <span class="pln">createdAt</span> <span class="pln">time</span><span class="pun">.</span><span class="typ">Time</span><span class="pun">,</span> <span class="pln">err</span> <span class="pln">error</span><span class="pun">)</span> <span class="pun">{</span>
</code></pre>

<p>I think the anonymous interface is actually <em>clearer</em> than the named one for most single-method interfaces.</p>

<p>Both anonymous structs and interfaces can be generic, too.</p>

<h2>zero-sized type (“ZST”)</h2>

<p>The empty struct <code>struct{}</code> and arrays of length zero (like <code>[0]int</code>) take up no memory, as do structs and arrays comprised entirely of zero-sized types.</p>

<p>A zero-sized type (“ZST”) is most often used as an interface handle, like <code>io.Discard</code>.</p>

<pre><code class="language-go">
<span class="pun">#</span><span class="pun">#</span> <span class="pln">zero</span><span class="pun">-</span><span class="pln">sized</span> <span class="pln">types</span>
<span class="com">// io/io.go</span>

<span class="com">// Discard is a Writer on which all Write calls succeed</span>
<span class="com">// without doing anything.</span>
<span class="kwd">var</span> <span class="typ">Discard</span> <span class="typ">Writer</span> <span class="pun">=</span> <span class="pln">discard</span><span class="pun">{</span><span class="pun">}</span>
<span class="kwd">type</span> <span class="pln">discard</span> <span class="kwd">struct</span><span class="pun">{</span><span class="pun">}</span>

<span class="kwd">func</span> <span class="pun">(</span><span class="pln">discard</span><span class="pun">)</span> <span class="typ">Write</span><span class="pun">(</span><span class="pln">p</span> <span class="pun">[</span><span class="pun">]</span><span class="kwd">byte</span><span class="pun">)</span> <span class="pun">(</span><span class="kwd">int</span><span class="pun">,</span> <span class="pln">error</span><span class="pun">)</span> <span class="pun">{</span> <span class="kwd">return</span> <span class="pln">len</span><span class="pun">(</span><span class="pln">p</span><span class="pun">)</span><span class="pun">,</span> <span class="kwd">nil</span><span class="pun">}</span>
<span class="kwd">func</span> <span class="pun">(</span><span class="pln">discard</span><span class="pun">)</span> <span class="typ">WriteString</span><span class="pun">(</span><span class="pln">s</span> <span class="pln">string</span><span class="pun">)</span> <span class="pun">(</span><span class="kwd">int</span><span class="pun">,</span> <span class="pln">error</span><span class="pun">)</span> <span class="pun">{</span> <span class="kwd">return</span> <span class="pln">len</span><span class="pun">(</span><span class="pln">s</span><span class="pun">)</span><span class="pun">,</span> <span class="kwd">nil</span><span class="pun">}</span>
</code></pre>

<p>You can also use a ZST as a map value type to save space rather than using <code>map[string]bool</code></p>

<pre><code class="language-go"><span class="kwd">var</span> <span class="kwd">set</span> <span class="pun">=</span> <span class="kwd">make</span><span class="pun">(</span><span class="kwd">map</span><span class="pun">[</span><span class="pln">string</span><span class="pun">]</span><span class="kwd">struct</span><span class="pun">{</span><span class="pun">}</span><span class="pun">)</span>
</code></pre>

<p>but <em>don’t</em>: <code>map[string]bool</code> is just as fast and has a much cleaner api.</p>

<p>You can get kind of silly with this:</p>

<pre><code class="language-go"><span class="kwd">type</span> <span class="pln">cursedZST</span> <span class="pun">=</span> <span class="pun">[</span><span class="dec">0</span><span class="pun">]</span><span class="kwd">map</span><span class="pun">[</span><span class="kwd">struct</span><span class="pun">{</span><span class="pun">}</span><span class="pun">]</span><span class="kwd">struct</span><span class="pun">{</span><span class="pun">}</span> <span class="com">// don&#39;t do this.</span>
</code></pre>

<p>Zero-sized types have a third use, but we’ll need to talk about blank struct fields first.</p>

<h2>blank struct fields</h2>

<p>Struct types can have unreachable fields using the <a href="https://go.dev/ref/spec#Blank_identifier">blank identifier</a>, <code>_</code> as the field name. You can use blank fields:</p>

<ul>
<li><p>To pad a struct to a specific size or alignment.</p>

<p>This is occasionally handy for cool <code>unsafe</code> stuff like serializing or deserializing stuff straight from a bytestream.</p>

<pre><code class="language-go"> <span class="kwd">func</span> <span class="pln">main</span><span class="pun">(</span><span class="pun">)</span> <span class="pun">{</span> <span class="com">// https://go.dev/play/p/4H7V_kKDw5m</span>
 <span class="kwd">type</span> <span class="typ">Point</span> <span class="kwd">struct</span><span class="pun">{</span> <span class="typ">X</span><span class="pun">,</span> <span class="typ">Y</span><span class="pun">,</span> <span class="typ">Z</span> <span class="pln">uint16</span> <span class="pun">}</span>
 <span class="kwd">type</span> <span class="typ">PaddedPoint</span> <span class="kwd">struct</span> <span class="pun">{</span>
  <span class="typ">X</span><span class="pun">,</span> <span class="typ">Y</span><span class="pun">,</span> <span class="typ">Z</span> <span class="pln">uint16</span>
  <span class="pln">_</span>       <span class="pln">uint16</span>
 <span class="pun">}</span>
 <span class="kwd">const</span> <span class="pln">format</span> <span class="pun">=</span> <span class="str">&#34;%12v\t%v\t%v\n&#34;</span>
 <span class="pln">fmt</span><span class="pun">.</span><span class="typ">Printf</span><span class="pun">(</span><span class="pln">format</span><span class="pun">,</span> <span class="str">&#34;type&#34;</span><span class="pun">,</span> <span class="str">&#34;size&#34;</span><span class="pun">,</span> <span class="str">&#34;align&#34;</span><span class="pun">)</span>
 <span class="pln">fmt</span><span class="pun">.</span><span class="typ">Printf</span><span class="pun">(</span><span class="pln">format</span><span class="pun">,</span> <span class="str">&#34;Point&#34;</span><span class="pun">,</span> <span class="pln">unsafe</span><span class="pun">.</span><span class="typ">Sizeof</span><span class="pun">(</span><span class="typ">Point</span><span class="pun">{</span><span class="pun">}</span><span class="pun">)</span><span class="pun">,</span> <span class="pln">unsafe</span><span class="pun">.</span><span class="typ">Alignof</span><span class="pun">(</span><span class="typ">Point</span><span class="pun">{</span><span class="pun">}</span><span class="pun">)</span><span class="pun">)</span>
 <span class="pln">fmt</span><span class="pun">.</span><span class="typ">Printf</span><span class="pun">(</span><span class="pln">format</span><span class="pun">,</span> <span class="str">&#34;PaddedPoint&#34;</span><span class="pun">,</span> <span class="pln">unsafe</span><span class="pun">.</span><span class="typ">Sizeof</span><span class="pun">(</span><span class="typ">PaddedPoint</span><span class="pun">{</span><span class="pun">}</span><span class="pun">)</span><span class="pun">,</span> <span class="pln">unsafe</span><span class="pun">.</span><span class="typ">Alignof</span><span class="pun">(</span><span class="typ">PaddedPoint</span><span class="pun">{</span><span class="pun">}</span><span class="pun">)</span><span class="pun">)</span>
<span class="pun">}</span>
</code></pre>
<pre><code class="language-text">        <span class="kwd">type</span> <span class="pln">size</span> <span class="pln">align</span>
        <span class="typ">Point</span>    <span class="dec">6</span>     <span class="dec">2</span>
    <span class="typ">PaddedPoint</span>  <span class="dec">8</span>    <span class="dec">2</span>
</code></pre></li>

<li><p>A blank field makes it difficult to initialize a struct without specifying key names. So as not to waste space, use a <a href="#zero-sized-type"><code>zero-sized type</code></a> for this.</p>

<p>This means that if you add a field to the struct later, it’s not a breaking change for users.</p>

<pre><code class="language-go"><span class="kwd">type</span> <span class="typ">LogOptions</span> <span class="kwd">struct</span> <span class="pun">{</span>
    <span class="pln">_</span> <span class="pun">[</span><span class="dec">0</span><span class="pun">]</span><span class="kwd">int</span> 
    <span class="typ">Level</span> <span class="kwd">int8</span>
    <span class="typ">LogTime</span><span class="pun">,</span> <span class="typ">LogFile</span><span class="pun">,</span> <span class="typ">LogLine</span> <span class="kwd">bool</span>
<span class="pun">}</span>
</code></pre>
<p>Be careful with this: sometimes you <em>want</em> changes to the API to be breaking changes, and changing the size of commonly-used types can have unforseen performance ramifications.</p>

<blockquote>
<p><strong>WEIRD EDGE CASE WARNING:</strong> <strong>A ZERO-SIZED TYPE IS ONLY ZERO-SIZED IF IT’S NOT THE FINAL MEMBER OF THE STRUCT</strong>.</p>

<p>That is, do this:</p>

<pre><code class="language-go"><span class="kwd">type</span> <span class="pln">s</span> <span class="kwd">struct</span> <span class="pun">{</span>
       <span class="pln">_</span> <span class="pun">[</span><span class="dec">0</span><span class="pun">]</span><span class="kwd">func</span><span class="pun">(</span><span class="pun">)</span>
       <span class="pln">a</span> <span class="kwd">int</span>
<span class="pun">}</span>
</code></pre>

<p>And not this:</p>

<pre><code class="language-go"><span class="kwd">type</span> <span class="pln">s</span> <span class="kwd">struct</span> <span class="pun">{</span>
   <span class="pln">a</span> <span class="kwd">int</span>
   <span class="pln">_</span> <span class="pun">[</span><span class="dec">0</span><span class="pun">]</span><span class="kwd">func</span><span class="pun">(</span><span class="pun">)</span>
<span class="pun">}</span>
</code></pre>

<p>See <a href="https://github.com/golang/go/issues/58483">issue 58483</a>. I found this out in a response to this article!</p>
</blockquote>

<p>Blank fields should be used sparingly, but can be nice for configuration.</p></li>

<li><p>Adding a field of uncomparable type makes the entire struct uncomparable.</p>

<p>Structs comprised only of <a href="https://go.dev/ref/spec#Comparison_operators">comparable</a> types (that is, ones where you can use the <code>==</code> operator) are themselves comparable, and can be used as keys in hashmaps or compared using <code>==</code>. The compiler implements these by generating comparison and hash functions for each comparable type in your code. This (very slightly) bloats the binary &amp; compilation time. You may not want this to happen. Prevent this having a blank field of uncomparable type (the usual candidate is the ZST <code>[0]func()</code>). If you have the kind of performance requirements that need this, you’ll know. Don’t do it “just because”; it’s confusing.</p></li>

<li><p>Blank fields can provide hints to tooling like <code>go vet</code> about how a type should be used. The most famous example of this is <code>copylock</code>. See <a href="https://github.com/golang/go/issues/8005#issuecomment-190753527">go issue #8005</a> for more details.</p></li>
</ul>

<h3>Putting it together: A generic zero-sized type</h3>

<p>As weird as it sounds, I have a use for a <strong>zero-sized</strong>, <strong>generic</strong> struct with unreachable members:<br/>
<code>context.WithValue</code>.</p>

<p>Let’s review the documentation:</p>

<blockquote>
<h4><code>func WithValue(parent Context, key, val any) Context</code></h4>

<p>WithValue returns a copy of parent in which the value associated with key is
val.
Use context Values only for <strong>request-scoped data that transits processes and
APIs</strong>, not for passing optional parameters to functions.
The provided key must be comparable and should not be of type
string or any other built-in type to avoid collisions between
packages using context. <strong>Users of WithValue should define their own
types for keys. To avoid allocating when assigning to an
<code>interface{}</code>, context keys often have concrete type
<code>struct{}</code>.</strong> Alternatively, exported context key variables’ static
type should be a pointer or interface.</p>
</blockquote>

<p>Most <strong>request-scoped data</strong> is a singleton per request. That is, it doesn’t make sense for a request to carry around multiple loggers, users, traces; you want to carry the <em>same one</em> with you from function call to function call</p>

<p>The usual way Go programs have handled this is by making a separate context key per type you want to carry in the struct. But with the advent of generics in <code>go1.18</code>, instead of having to make a new zero-sized type for every struct, we can just make a single generic zero-sized type and use it for everything:</p>

<pre><code class="language-go"><span class="kwd">type</span> <span class="pln">key</span><span class="pun">[</span><span class="typ">T</span><span class="pun">]</span> <span class="kwd">struct</span><span class="pun">{</span><span class="pun">}</span>
<span class="com">// FromCtx returns the value of type T stored in the context, if any:</span>
<span class="kwd">func</span> <span class="typ">FromCtx</span><span class="pun">[</span><span class="typ">T</span><span class="pun">]</span><span class="pun">(</span><span class="pln">ctx</span> <span class="pln">context</span><span class="pun">)</span> <span class="pun">(</span><span class="typ">T</span><span class="pun">,</span> <span class="kwd">bool</span><span class="pun">)</span> <span class="pun">{</span> 
    <span class="pln">t</span><span class="pun">,</span> <span class="pln">ok</span> <span class="pun">:</span><span class="pun">=</span> <span class="pln">context</span><span class="pun">.</span><span class="typ">Value</span><span class="pun">(</span><span class="pln">key</span><span class="pun">[</span><span class="typ">T</span><span class="pun">]</span><span class="pun">{</span><span class="pun">}</span><span class="pun">)</span><span class="pun">.</span><span class="pun">(</span><span class="typ">T</span><span class="pun">)</span>
    <span class="kwd">return</span> <span class="pln">t</span><span class="pun">,</span> <span class="pln">ok</span>
<span class="pun">}</span>
<span class="com">// WithValue returns a copy of parent in which the value associated with `CtxKey[T]{}` is</span>
<span class="com">// val.</span>
<span class="kwd">func</span> <span class="typ">WithValue</span><span class="pun">[</span><span class="typ">T</span><span class="pun">]</span><span class="pun">(</span><span class="pln">ctx</span> <span class="pln">context</span><span class="pun">,</span> <span class="pln">t</span> <span class="typ">T</span><span class="pun">)</span><span class="pun">(</span><span class="pln">context</span><span class="pun">.</span><span class="typ">Context</span><span class="pun">)</span> <span class="pun">{</span>
    <span class="kwd">return</span> <span class="pln">context</span><span class="pun">.</span><span class="typ">WithValue</span><span class="pun">(</span><span class="pln">ctx</span><span class="pun">,</span> <span class="pln">key</span><span class="pun">[</span><span class="typ">T</span><span class="pun">]</span><span class="pun">{</span><span class="pun">}</span><span class="pun">,</span> <span class="pln">t</span><span class="pun">)</span>
<span class="pun">}</span>
</code></pre>

<p>For fun, let’s rewrite <code>FromCtx</code> as a truly hellish one-liner using (nearly) every trick we’ve learned so far:</p>

<pre><code class="language-go"><span class="kwd">func</span> <span class="typ">FromCtx</span><span class="pun">[</span><span class="typ">T</span> <span class="pln">any</span><span class="pun">]</span><span class="pun">(</span><span class="pln">ctx</span> <span class="pln">context</span><span class="pun">.</span><span class="typ">Context</span><span class="pun">)</span> <span class="pun">(</span><span class="typ">T</span><span class="pun">,</span> <span class="kwd">bool</span><span class="pun">)</span> <span class="pun">{</span><span class="pln">t</span><span class="pun">,</span> <span class="pln">ok</span> <span class="pun">:</span><span class="pun">=</span> <span class="pln">context</span><span class="pun">.</span><span class="typ">Context</span><span class="pun">.</span><span class="typ">Value</span><span class="pun">(</span><span class="pln">ctx</span><span class="pun">,</span> <span class="pun">[</span><span class="dec">0</span><span class="pun">]</span><span class="kwd">struct</span><span class="pun">{</span><span class="pln">_</span> <span class="typ">T</span><span class="pun">}</span><span class="pun">)</span><span class="pun">.</span><span class="pun">(</span><span class="typ">T</span><span class="pun">)</span><span class="pun">;</span><span class="kwd">return</span> <span class="pln">t</span><span class="pun">,</span> <span class="pln">ok</span><span class="pun">}</span>
</code></pre>

<p>That’s right: this ugly SOB has a</p>

<ul>
<li>zero-sized type</li>
<li>containing an anonymous <code>struct</code></li>
<li>with a blank identifier</li>
<li>in a method expression</li>
<li>on a semi-colon terminated multi-statement line</li>
</ul>

<p>… please don’t do this.</p>

<h3>Next time(?)</h3>

<ul>
<li>More contradictions and corner cases</li>
<li>Advanced generics</li>
<li>Unsafe</li>
<li>Runtime shenanigans</li>
</ul>

<p>Like this article? Hire me, or bring me in to consult. Professional enquiries at
<a href="efron.dev@mail.com">efron.dev@gmail.com</a> or <a href="https://www.linkedin.com/in/efronlicht">linkedin</a></p>



